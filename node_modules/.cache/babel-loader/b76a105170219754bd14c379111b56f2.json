{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport Web3 from \"web3\";\nimport web3CoreSubscriptions from \"web3-core-subscriptions\";\nimport { decodeParameter } from \"web3-eth-abi\";\nimport { toHex } from \"web3-utils\";\nimport { formatBlock } from \"./util/hex\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nimport { patchEnableCustomRPC } from \"./web3-adapter/customRPC\";\nimport { patchEthFeeHistoryMethod } from \"./web3-adapter/eth_feeHistory\";\nimport { patchEthMaxPriorityFeePerGasMethod } from \"./web3-adapter/eth_maxPriorityFeePerGas\";\nvar DEFAULT_MAX_RETRIES = 3;\nvar DEFAULT_RETRY_INTERVAL = 1000;\nvar DEFAULT_RETRY_JITTER = 250;\nexport var AssetTransfersCategory;\n\n(function (AssetTransfersCategory) {\n  AssetTransfersCategory[\"EXTERNAL\"] = \"external\";\n  AssetTransfersCategory[\"INTERNAL\"] = \"internal\";\n  AssetTransfersCategory[\"TOKEN\"] = \"token\";\n  AssetTransfersCategory[\"ERC20\"] = \"erc20\";\n  AssetTransfersCategory[\"ERC721\"] = \"erc721\";\n  AssetTransfersCategory[\"ERC1155\"] = \"erc1155\";\n})(AssetTransfersCategory || (AssetTransfersCategory = {}));\n\nexport var AssetTransfersOrder;\n\n(function (AssetTransfersOrder) {\n  AssetTransfersOrder[\"ASCENDING\"] = \"asc\";\n  AssetTransfersOrder[\"DESCENDING\"] = \"desc\";\n})(AssetTransfersOrder || (AssetTransfersOrder = {}));\n\nexport function createAlchemyWeb3(alchemyUrl, config) {\n  var fullConfig = fillInConfigDefaults(config);\n\n  var _a = makeAlchemyContext(alchemyUrl, fullConfig),\n      provider = _a.provider,\n      senders = _a.senders,\n      setWriteProvider = _a.setWriteProvider;\n\n  var alchemyWeb3 = new Web3(provider);\n\n  alchemyWeb3.setProvider = function () {\n    throw new Error(\"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\");\n  };\n\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: function getTokenAllowance(params, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params]\n      });\n    },\n    getTokenBalances: function getTokenBalances(address, contractAddresses, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses],\n        processResponse: processTokenBalanceResponse\n      });\n    },\n    getTokenMetadata: function getTokenMetadata(address, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\"\n      });\n    },\n    getAssetTransfers: function getAssetTransfers(params, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        params: [__assign(__assign({}, params), {\n          fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n          toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n          maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n        })],\n        method: \"alchemy_getAssetTransfers\"\n      });\n    },\n    getNftMetadata: function getNftMetadata(params, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        params: [__assign({}, params)],\n        method: \"alchemy_getNftMetadata\"\n      });\n    }\n  };\n  patchSubscriptions(alchemyWeb3);\n  patchEnableCustomRPC(alchemyWeb3);\n  patchEthFeeHistoryMethod(alchemyWeb3);\n  patchEthMaxPriorityFeePerGasMethod(alchemyWeb3);\n  return alchemyWeb3;\n}\n\nfunction fillInConfigDefaults(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.writeProvider,\n      writeProvider = _c === void 0 ? getWindowProvider() : _c,\n      _d = _b.maxRetries,\n      maxRetries = _d === void 0 ? DEFAULT_MAX_RETRIES : _d,\n      _e = _b.retryInterval,\n      retryInterval = _e === void 0 ? DEFAULT_RETRY_INTERVAL : _e,\n      _f = _b.retryJitter,\n      retryJitter = _f === void 0 ? DEFAULT_RETRY_JITTER : _f;\n\n  return {\n    writeProvider: writeProvider,\n    maxRetries: maxRetries,\n    retryInterval: retryInterval,\n    retryJitter: retryJitter\n  };\n}\n\nfunction getWindowProvider() {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\n\nfunction callAlchemyMethod(_a) {\n  var _this = this;\n\n  var senders = _a.senders,\n      method = _a.method,\n      params = _a.params,\n      _b = _a.callback,\n      callback = _b === void 0 ? noop : _b,\n      _c = _a.processResponse,\n      processResponse = _c === void 0 ? identity : _c;\n\n  var promise = function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , senders.send(method, params)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , processResponse(result)];\n        }\n      });\n    });\n  }();\n\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction processTokenBalanceResponse(rawResponse) {\n  // Convert token balance fields from hex-string to decimal-string.\n  var fixedTokenBalances = rawResponse.tokenBalances.map(function (balance) {\n    return balance.tokenBalance != null ? __assign(__assign({}, balance), {\n      tokenBalance: decodeParameter(\"uint256\", balance.tokenBalance)\n    }) : balance;\n  });\n  return __assign(__assign({}, rawResponse), {\n    tokenBalances: fixedTokenBalances\n  });\n}\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions.\n */\n\n\nfunction patchSubscriptions(web3) {\n  var eth = web3.eth;\n  var oldSubscribe = eth.subscribe.bind(eth);\n\n  eth.subscribe = function (type) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    if (type === \"alchemy_fullPendingTransactions\" || type === \"alchemy_newFullPendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_newFullPendingTransactions\"], __read(rest)));\n      });\n    }\n\n    if (type === \"alchemy_filteredNewFullPendingTransactions\" || type === \"alchemy_filteredPendingTransactions\" || type === \"alchemy_filteredFullPendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_filteredNewFullPendingTransactions\"], __read(rest)));\n      });\n    }\n\n    return oldSubscribe.apply(void 0, __spreadArray([type], __read(rest)));\n  };\n}\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\n\n\nfunction suppressNoSubscriptionExistsWarning(f) {\n  var oldConsoleWarn = console.warn;\n\n  console.warn = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (typeof args[0] === \"string\" && args[0].includes(\" doesn't exist. Subscribing anyway.\")) {\n      return;\n    }\n\n    return oldConsoleWarn.apply(console, args);\n  };\n\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n/**\n * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions\n * I hate doing this, but the other option is to fork web3-core and I think for now this is better\n */\n\n\nvar subscription = web3CoreSubscriptions.subscription;\nvar oldSubscriptionPrototypeValidateArgs = subscription.prototype._validateArgs;\n\nsubscription.prototype._validateArgs = function (args) {\n  if ([\"alchemy_filteredNewFullPendingTransactions\", \"alchemy_filteredPendingTransactions\", \"alchemy_filteredFullPendingTransactions\"].includes(this.subscriptionMethod)) {// This particular subscription type is allowed to have additional parameters\n  } else {\n    if ([\"alchemy_fullPendingTransactions\", \"alchemy_newFullPendingTransactions\"].includes(this.subscriptionMethod)) {\n      if (this.options.subscription) {\n        this.options.subscription.subscriptionName = this.subscriptionMethod;\n      }\n    }\n\n    var validator = oldSubscriptionPrototypeValidateArgs.bind(this);\n    validator(args);\n  }\n};\n\nfunction noop() {// Nothing.\n}\n\nfunction identity(x) {\n  return x;\n}","map":null,"metadata":{},"sourceType":"module"}